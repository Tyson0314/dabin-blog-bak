(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{650:function(t,n,e){"use strict";e.r(n);var s=e(14),r=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),e("p",[t._v("使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。")]),t._v(" "),e("p",[t._v("如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的某些列就是需要索引的对象。")]),t._v(" "),e("p",[t._v("避免使用OR。通过使用多条SELECT语句和连接它们的UNION语句，会有极大的性能改进。")]),t._v(" "),e("p",[t._v("LIKE很慢，最好是使用FULLTEXT而不是LIKE。")]),t._v(" "),e("p",[t._v("很多高性能的应用都会对关联查询进行分解，有如下的优势：")]),t._v(" "),e("p",[t._v("1 、让缓存效率更高。如果某张表很少变化，那么基于该表的查询就可以重复利用查询缓存结果。\n2 、将查询分解后，执行单个查询可以减少锁的竞争。\n3 、在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。\n4 、查询本身效率也可能会有所提升。例如 IN()代替关联查询，可能比随机的关联更高效。\n5 、减少冗余记录得查询。\n6 、更进一步，这样做相当于在应用中实现了哈希关联，而不是使用 MySQL 得嵌套循环关联。某些场景哈希关联得效率要高很多。")])])}),[],!1,null,null,null);n.default=r.exports}}]);